

//int main() {
//	Solution offer;
	//vector<int> test_duplicate_jz3;
	//test_duplicate_jz3 = { 2, 3, 1, 0, 2, 5, 3 };
	//cout << "jz3 return: " << offer.duplicate(test_duplicate_jz3) << endl;
	//cout << "jz3 return: " << offer.duplicate2(test_duplicate_jz3) << endl; //这个在牛客网无法通过

	//vector<int> tests1_Find_jz4 = { 1,2,8,9 };
	//vector<int> tetss2_Find_jz4 = { 2,4,9,12 };
	//vector<int> tests3_Find_jz4 = { 4,7,10,13 }; 
	//vector<int> tests4_Find_jz4 = { 6, 8, 11, 15 };
	//vector<vector<int>> tests_Find_jz4;
	//tests_Find_jz4.push_back(tests1_Find_jz4);
	//tests_Find_jz4.push_back(tests1_Find_jz4);
	//tests_Find_jz4.push_back(tests1_Find_jz4);
	//tests_Find_jz4.push_back(tests1_Find_jz4);
	//cout<<"jz4 return: "<<offer.Find1(7, tests_Find_jz4)<<endl;

	//vector<int> tests_Find_jz11 = {1,0,0,1,1,1,1,1};
	//cout << offer.minNumberInRotateArray(tests_Find_jz11) << endl;

	/*vector<vector<char>> matrix = {
		{'a','b','c','e'},
		{'s','f','c','s'},
		{'a','d','e','e'},
	};*/

	/* [[A, B, C, E, H, J, I, G], 
		[S, F, C, S, L, O, P, Q], 
		[A, D, E, E, M, N, O, E], 
		[A, D, I, D, E, J, F, M], 
		[V, C, E, I, F, G, G, S]], 
		"SGGFIECVAASABCEHJIGQEM"
		[[A,B,C,E,H,J,I,G],
		[z`,F,C,S,L,O,P,Q],
		[A,D,E,E,M,N,O,E],
		[A,D,I,D,E,J,F,M],
		[V,C,E,I,F,G,G,S]]
		"SGGFIECVAASABCEHJIGQEM"*/

	//offer.hasPath(matrix,"abcced");

	//cout<<offer.movingCount(1, 2, 3);
	/*0 1 2 3 4 5 6
	  1 2 3 4 5 6 7
	  2 3 4 5 6 7 8
	  3 4 5 6 7 8 9
	  4 5 6 7 8 9 10*/

	
	//cout << offer2.cutRope(18) << " " << offer2.cutRope_DP(18);
	//cout << offer2.NumberOf1(6)  <<" ";
	//cout << offer2.NumberOf1(10) << " ";
	//cout << offer2.NumberOf1(16) << " ";
	//cout << offer2.NumberOf1(-0) << " ";

	/*cout << offer2.Power(2.10000, 3)<<" ";
	cout << offer2.Power_DP(2.10000, 3);*/

	//offer2.match("aaaabbbcc","c*a*d");
	//cout << "  -123" << endl;
	//if (offer2.isNumeric("+")) cout << "true" << endl;
	//else cout << "false";
	//vector<int>c{ 1,3,5,6,7 };
	//for (auto x: offer2.reOrderArray(c)) {
	//	cout << x << " ";
	//}

	//Solution4 s4;
	//TreeNode* root = nullptr;
	//TreeNode* left1 = nullptr;
	//TreeNode* right1 = nullptr;
	//root->val = 1;
	//left1->val = 2;
	//right1->val = 3;
	//root->left = left1;
	//root->right = right1;
	//s4.
	//return 0;
//}